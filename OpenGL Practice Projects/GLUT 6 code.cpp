#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
float angle=0.0;
void init0()
{
    glClearColor(0,0,0,1);//specify clear values for the color buffers
    glEnable(GL_DEPTH_TEST);//glEnable enable or disable server-side GL capabilities, GL_DEPTH_TEST When rendering to a framebuffer that has no depth buffer, depth testing always behaves as though the test is disabled. When depth testing is disabled, writes to the depth buffer are also disabled.
}
void display()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//clear buffers to preset values,GL_COLOR_BUFFER_BIT clears the OpenGL color and depth buffers,GL_DEPTH_BUFFER_BIT Indicates the depth buffer.

    glLoadIdentity();//replace the current matrix with the identity matrix
    //draw

    //glTranslatef(x_position,0,0);

    glTranslatef(0,0,-8);

    glRotatef(angle,1,0,0);//multiply the current matrix by a rotation matrix
    glRotatef(angle,0,1,0);
    glRotatef(angle,0,0,1);

    glRotatef(angle,0,1,0);
    glRotatef(angle,0,0,1);
    glRotatef(angle,1,0,0);

    glRotatef(angle,0,0,1);
    glRotatef(angle,1,0,0);
    glRotatef(angle,0,1,0);

    glRotatef(angle,1,0,1);//multiply the current matrix by a rotation matrix
    glRotatef(angle,1,1,0);
    glRotatef(angle,1,0,1);

    glRotatef(angle,0,1,0);
    glRotatef(angle,0,1,1);
    glRotatef(angle,1,1,0);

    glRotatef(angle,1,0,1);
    glRotatef(angle,1,1,0);
    glRotatef(angle,0,1,0);

    glRotatef(angle,1,1,1);//multiply the current matrix by a rotation matrix
    glRotatef(angle,0,1,1);
    glRotatef(angle,1,0,1);

    glRotatef(angle,1,1,0);
    glRotatef(angle,0,1,1);
    glRotatef(angle,1,1,0);

    glRotatef(angle,1,0,1);
    glRotatef(angle,1,0,1);
    glRotatef(angle,0,1,0);

     glBegin(GL_QUADS);//GL_QUADS Treats each vertices as an independent quadrilateral

     //glColor3f(1,0,0);//set the current color

     //glShadeModel(GL_FLAT);//select flat or smooth shading, by default shading is GL_SMOOTH = causes the computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning different colors to each resulting pixel fragment,GL_FLAT = Flat shading selects the computed color of just one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive

    //front
    glColor3f(1.0,0.0,0.0);//anticlockwise
    glVertex3f(-1.0,1.0,1.0);
    glVertex3f(-1.0,-1.0,1.0);
    glVertex3f(1.0,-1.0,1.0);
    glVertex3f(1.0,1.0,1.0);

    //back
    glColor3f(0.0,1.0,0.0);//clockwise
    glVertex3f(1.0,1.0,-1.0);
    glVertex3f(1.0,-1.0,-1.0);
    glVertex3f(-1.0,-1.0,-1.0);
    glVertex3f(-1.0,1.0,-1.0);

    //right
    glColor3f(0.0,0.0,1.0);
    glVertex3f(1.0,1.0,1.0);
    glVertex3f(1.0,-1.0,1.0);
    glVertex3f(1.0,-1.0,-1.0);
    glVertex3f(1.0,1.0,-1.0);

    //left
    glColor3f(1.0,1.0,0.0);
    glVertex3f(-1.0,1.0,-1.0);
    glVertex3f(-1.0,-1.0,-1.0);
    glVertex3f(-1.0,-1.0,1.0);
    glVertex3f(-1.0,1.0,1.0);

    //top
    glColor3f(0.0,1.0,1.0);
    glVertex3f(-1.0,1.0,-1.0);
    glVertex3f(-1.0,1.0,1.0);
    glVertex3f(1.0,1.0,1.0);
    glVertex3f(1.0,1.0,-1.0);

    //bottom
    glColor3f(1.0,0.0,1.0);
    glVertex3f(-1.0,-1.0,-1.0);
    glVertex3f(-1.0,-1.0,1.0);
    glVertex3f(1.0,-1.0,1.0);
    glVertex3f(1.0,-1.0,-1.0);

   angle=angle+0.5;
    if (360.0<angle)
        angle=0;

    glEnd();//delimit the vertices of a primitive or a group of like primitives

    glutSwapBuffers();//swaps the buffers of the current window if double buffered
}
void reshape(int w, int h)
{
    glViewport(0,0,w,h);//set the viewport
    glMatrixMode(GL_PROJECTION);//specify which matrix is the current matrix, GL_PROJECTION applies subsequent matrix operations to the projection matrix stack
    glLoadIdentity();//replace the current matrix with the identity matrix

    gluPerspective(60,1.7786,2,50);//set up a perspective projection matrix//aspect ratio = 1366/768 =1.7786
    glMatrixMode(GL_MODELVIEW);//GL_MODELVIEW applies subsequent matrix operations to the modelview matrix stack,GL_MODELVIEW applies subsequent matrix operations to the modelview matrix stack
}
void timer(int)
{
    glutPostRedisplay();//marks the current window as needing to be redisplayed
    glutTimerFunc(17,timer,0 );//1000/60=16.6667=17
}
int main(int argc,char** argv)//argc parameter represents the number of command line arguments, and char *argv[] is an array of strings (character pointers) representing the individual arguments provided on the command line
{
    glutInit(&argc,argv);//used to initialize the GLUT library
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);//sets the initial display mode,GLUT_RGB is Bit mask to select a color index mode window, In a double buffered scenario (GLUT_DOUBLE), there exist two framebuffer. One is used for drawing, the other one for display. At the end of each frame, these buffers are swapped,GLUT_DEPTH bit mask to select a window with a depth buffer

    glutInitWindowPosition(0,0);//creates window from this location
    glutInitWindowSize(1366,768);//window size

    glutCreateWindow("Window1");//call back function, it creates a top-level window

    glutReshapeFunc(reshape);//call back function resize, it adjust graphics once it is resized
    glutDisplayFunc(display);//sets the display callback for the current window

    glutTimerFunc(0,timer,0);//registers a timer callback to be triggered in a specified number of milliseconds. 1000ms=1s
     init0();
    glutMainLoop();//enters the GLUT event processing loop
}




